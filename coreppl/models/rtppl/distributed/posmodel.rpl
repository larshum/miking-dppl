type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = {row : Int, col : Int}

type Pos = { x : Float, y : Float, direction : Float }

const roomBlockWidth : Float = 0.1
const maxSpeed : Float = 0.5
const wheelCircumference : Float = 0.35

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.1
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

// We estimate the current speed of the car based on the observed speeds from
// the left and right wheels. Note that this model does not make use of earlier
// estimations, as the current speed of the car does not depend much on the
// speed during our previous estimation. (it might be a good idea to include
// that as well)
def speedModel(inputs : [TSV(Float)]) : Float {
  assume v ~ Uniform(0.0 - maxSpeed, maxSpeed)
  loop for tsv in inputs {
    var ts : Int = timestamp(tsv)
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    var rpm : Float = value(tsv)
    var mps : Float = rpm * wheelCircumference / 60.0
    observe mps ~ Gaussian(v, sigma)
  }
  cond if v < 0.0-maxSpeed || v > maxSpeed {
    degenerate
  } else {}
  resample
  return v
}

def speedEst(period : Int) : Unit {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Float)
  loop {
    sdelay period
    read lspeed to lin
    read rspeed to rin
    var inputs : [TSV(Float)] = concat(lin, rin)
    infer d <- speedModel(inputs) particles 1000
    write d to speed
  }
}

// Estimates the "true" distance between the car and an obstacle given
// observations from one or multiple sensors placed at a certain direction.
//
// TODO: ensure that this model takes the offset of the sensors into account
// when estimating the distance - we want to estimate the distance from the
// front of the car to the wall, not from the center of the car to the wall.
def distanceModel(prior : Dist(Float), dists : [TSV(Float)],
                  speeds : [TSV(Dist(Float))], maxSensorDistance : Float) : Float {
  // We sample from the prior to get the distance estimate from our previous
  // iteration.
  assume dprev ~ prior

  // Add uncertainty in the new distance based on our speed estimations. When
  // the car is stationary, the distance should not change, while if the car is
  // moving fast the model assumes it is more likely to change than if it is
  // moving slower.
  var dist : Float = dprev
  loop dist for tsv in speeds {
    assume v ~ value(tsv)
    var sigma : Float = v * timeRelativeSigma(timestamp(tsv))
    assume dist ~ Gaussian(dist, sigma)
  }

  loop for tsv in dists {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    var obsDist : Float = value(tsv)
    cond if not(obsDist > maxSensorDistance) {
      cond if dist > maxSensorDistance {
        degenerate
      } else {
        observe obsDist ~ Gaussian(dist, sigma)
      }
    } else {}
  }

  cond if dist < 0.0 || dist > 10.0 {
    degenerate
  } else {}
  resample
  return dist
}

def ultrasonicDistance(period : Int) : Unit {
  input ldist : Float
  input rdist : Float
  input speed : Dist(Float)
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read ldist to lin
    read rdist to rin
    var dists : [TSV(Float)] = concat(lin, rin)
    read speed to speeds
    infer d <- distanceModel(d, dists, speeds, 2.0) particles 1000
    write d to dist
  }
}

def tofDistance(period : Int) : Unit {
  input distIn : Float
  input speed : Dist(Float)
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distIn to tsvs
    read speed to speeds
    infer d <- distanceModel(d, tsvs, speeds, 4.0) particles 1000
    write d to dist
  }
}

def initialPositionModel(blocks : [Coordinate]) : Pos {
  var c : Coordinate = randElemExn(blocks)
  var x : Float = intToFloat(c.col) * roomBlockWidth
  var y : Float = intToFloat(c.row) * roomBlockWidth
  assume xOfs ~ Uniform(0.0, roomBlockWidth)
  assume yOfs ~ Uniform(0.0, roomBlockWidth)
  assume d ~ Uniform(0.0, 2.0 * pi)
  return { x = x + xOfs, y = y + yOfs, direction = d }
}

def estimateDistance(m : RoomMap, pos : Pos) : Float {
  var eps : Float = 0.05
  var acc : {d : Float, p : Pos} = {d = 0.0, p = pos}
  loop acc while withinRoomBounds(m, acc.p) {
    var p : Pos = acc.p
    p.x = p.x + eps * cos(p.direction)
    p.y = p.y + eps * sin(p.direction)
    acc.d = acc.d + eps
    acc.p = p
  }
  return acc.d
}

def estimateDistanceFront(m : RoomMap, p : Pos) : Float {
  return estimateDistance(m, p)
}

def estimateDistanceRear(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction + pi
  return estimateDistance(m, p)
}

def estimateDistanceSideLeft(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction - pi / 2.0
  return estimateDistance(m, p)
}

def estimateDistanceSideRight(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction + pi / 2.0
  return estimateDistance(m, p)
}

def positionModel(m : RoomMap, prior : Dist(Pos), front : [TSV(Dist(Float))],
                  rear : [TSV(Dist(Float))], left : [TSV(Dist(Float))],
                  right : [TSV(Dist(Float))]) : Pos {
  assume posPrev ~ prior

  // TODO: Transition to "new" position - for now, we simply guess the new
  // direction, ignoring steering angle and speed.
  assume x ~ Gaussian(posPrev.x, maxSpeed)
  assume y ~ Gaussian(posPrev.y, maxSpeed)
  assume d ~ Uniform(0.0, 2.0 * pi)
  var pos : Pos = {x = x, y = y, direction = d}

  // Update our belief of the current position based on observations
  var frontEst : Float = estimateDistanceFront(m, pos)
  loop for tsv in front {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    assume frontObs ~ value(tsv)
    observe frontObs ~ Gaussian(frontEst, sigma)
  }
  var rearEst : Float = estimateDistanceRear(m, pos)
  loop for tsv in rear {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    assume rearObs ~ value(tsv)
    observe rearObs ~ Gaussian(rearEst, sigma)
  }
  var leftEst : Float = estimateDistanceSideLeft(m, pos)
  loop for tsv in left {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    assume leftObs ~ value(tsv)
    observe leftObs ~ Gaussian(leftEst, sigma)
  }
  var rightEst : Float = estimateDistanceSideRight(m, pos)
  loop for tsv in right {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    assume rightObs ~ value(tsv)
    observe rightObs ~ Gaussian(rightEst, sigma)
  }

  cond if not(withinRoomBounds(m, pos)) {
    degenerate
  } else {}
  resample

  return pos
}

def positionEstimate(period : Int) : Unit {
  input front : Dist(Float)
  input rear : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input steeringAngle : Float
  output pos : Dist(Pos)
  //var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer d <- initialPositionModel(blocks) particles 1000
  loop {
    sdelay period
    read front to frontIn
    read rear to rearIn
    read left to leftIn
    read right to rightIn
    infer d <- positionModel(m, d, frontIn, rearIn, leftIn, rightIn) budget 900ms
    write d to pos
  }
}

// TODO: add parameter configuring how "agressive" the braking should be, i.e.,
// how much risk we're willing to take. How do we inspect the position
// estimation?
def brakeEstimate(period : Int) : Unit {
  input pos : Dist(Pos)
  output brake : Float
  loop {
    sdelay period
  }
}

main {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not (what kind of value do
  // we want to write to this?)
  actuator brake : Float

  task speedEst = speedEst(500ms)
  task frontDist = ultrasonicDistance(500ms)
  task rearDist = ultrasonicDistance(500ms)
  task leftDist = tofDistance(500ms)
  task rightDist = tofDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(1s)

  // Network specification
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed
  speedEst.speed -> frontDist.speed
  speedEst.speed -> rearDist.speed
  speedEst.speed -> leftDist.speed
  speedEst.speed -> rightDist.speed
  frontLeft -> frontDist.ldist
  frontRight -> frontDist.rdist
  rearLeft -> rearDist.ldist
  rearRight -> rearDist.rdist
  sideLeft -> leftDist.distIn
  sideRight -> rightDist.distIn
  frontDist.dist -> pos.front
  rearDist.dist -> pos.rear
  leftDist.dist -> pos.left
  rightDist.dist -> pos.right
  steeringAngle -> pos.steeringAngle
  pos.pos -> brake.pos
  brake.brake -> brake
}
