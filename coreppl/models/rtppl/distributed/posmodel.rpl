type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = {row : Int, col : Int}

type Pos = { x : Float, y : Float, direction : Float, speed : Float }

const roomBlockWidth : Float = 0.1
const maxSpeed : Float = 0.5
const wheelCircumference : Float = 0.35
const ultrasonicMaxRange : Float = 4.0
const tofMaxRange : Float = 2.0

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.01
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

// We estimate the current speed of the car based on the observed speeds from
// the left and right wheels. Note that this model does not make use of earlier
// estimations, as the current speed of the car does not depend much on the
// speed during our previous estimation. (it might be a good idea to include
// that as well)
def speedModel(prior : Dist(Float), observations : [TSV(Float)]) : Float {
  // Start from our earlier estimation of the speed (in meters per second).
  assume vprev ~ prior

  // Our new belief of the speed is normally distributed around our old belief.
  // TODO: choose sigma based on the max acceleration of the car.
  assume v ~ Gaussian(vprev, 0.1)

  loop for tsv in observations {
    var ts : Int = timestamp(tsv)
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 5.0
    var rpm : Float = value(tsv)
    var mps : Float = rpm * wheelCircumference / 60.0
    observe mps ~ Gaussian(v, sigma)
  }
  cond if v < 0.0-maxSpeed || v > maxSpeed {
    degenerate
  } else {}
  resample
  return v
}

def speedEst(period : Int) : Unit {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Float)
  var d : Dist(Float) = Uniform(0.0-0.5, 0.5)
  loop d {
    sdelay period
    read lspeed to lin
    read rspeed to rin
    var obs : [TSV(Float)] = concat(lin, rin)
    infer d <- speedModel(d, obs) particles 1000
    write d to speed
  }
}

// Estimates the "true" distance between the car and an obstacle given
// observations from one or multiple sensors placed at a certain direction.
def distanceModel(prior : Dist(Float), dists : [TSV(Float)],
                  maxSensorRange : Float) : Float {
  // We sample from the prior to get the distance estimate from our previous
  // iteration.
  assume dprev ~ prior

  // We are uncertain about the new distance, but we assume it is related to
  // our previous estimate through a normal distribution.
  assume d ~ Gaussian(dprev, 1.0)

  loop for tsv in dists {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    var obsDist : Float = value(tsv)
    // NOTE: The following approach assumes all observations provided by the
    // distance sensors are correct and relatively exact. This is true for the
    // simulator, but not for the car (in particular the ultrasonic sensors).
    cond if obsDist > maxSensorRange {
      cond if not(d > maxSensorRange) {
        degenerate
      } else {}
    } else {
      observe obsDist ~ Gaussian(d, sigma)
    }
  }

  cond if d < 0.0 || d > 10.0 {
    degenerate
  } else {}
  resample
  return d
}

def ultrasonicDistance(period : Int) : Unit {
  input ldist : Float
  input rdist : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read ldist to lin
    read rdist to rin
    var dists : [TSV(Float)] = concat(lin, rin)
    infer d <- distanceModel(d, dists, ultrasonicMaxRange) particles 1000
    write d to dist
  }
}

def tofDistance(period : Int) : Unit {
  input distIn : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distIn to tsvs
    infer d <- distanceModel(d, tsvs, tofMaxRange) particles 1000
    write d to dist
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
def initialPositionModel(blocks : [Coordinate]) : Pos {
  var c : Coordinate = randElemExn(blocks)
  var x : Float = intToFloat(c.col) * roomBlockWidth
  var y : Float = intToFloat(c.row) * roomBlockWidth
  assume xOfs ~ Uniform(0.0, roomBlockWidth)
  assume yOfs ~ Uniform(0.0, roomBlockWidth)
  return { x = x + xOfs, y = y + yOfs, direction = pi, speed = 0.0 }
}

// TODO: Take the sensor offsets into account when estimating the distance.
// The position denotes our belief of the center of the car.
def estimateDistance(m : RoomMap, pos : Pos) : Float {
  var eps : Float = 0.05
  var acc : {d : Float, p : Pos} = {d = 0.0, p = pos}
  loop acc while withinRoomBounds(m, acc.p) {
    var p : Pos = acc.p
    p.x = p.x + eps * cos(p.direction)
    p.y = p.y + eps * sin(p.direction)
    acc.d = acc.d + eps
    acc.p = p
  }
  return acc.d
}

def estimateDistanceFront(m : RoomMap, p : Pos) : Float {
  return estimateDistance(m, p)
}

def estimateDistanceRear(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction + pi
  return estimateDistance(m, p)
}

def estimateDistanceSideLeft(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction - pi / 2.0
  return estimateDistance(m, p)
}

def estimateDistanceSideRight(m : RoomMap, p : Pos) : Float {
  p.direction = p.direction + pi / 2.0
  return estimateDistance(m, p)
}

def positionModel(m : RoomMap, prior : Dist(Pos), front : [TSV(Dist(Float))],
                  rear : [TSV(Dist(Float))], left : [TSV(Dist(Float))],
                  right : [TSV(Dist(Float))], speed : [TSV(Dist(Float))]) : Pos {
  assume posPrev ~ prior

  // Update our belief of the speed of the car based on estimations from the
  // speed model.
  var v : Float = posPrev.speed
  loop v for tsv in speed {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    assume vEst ~ value(tsv)
    assume v ~ Gaussian(vEst, sigma)
  }
  // TODO: improve this estimation by making use of steering angle observations...
  assume d ~ Gaussian(posPrev.direction, pi / 2.0)

  // Use our estimated speed and direction to update our belief of the position
  // of the car.
  assume x ~ Gaussian(posPrev.x, v * cos(d))
  assume y ~ Gaussian(posPrev.y, v * sin(d))
  var pos : Pos = {x = x, y = y, direction = d, speed = v}

  // Update our belief of the current position based on observations
  var frontEst : Float = estimateDistanceFront(m, pos)
  loop for tsv in front {
    //var distTravelled : Float = pos.speed * intToFloat(timestamp(tsv)) / intToFloat(1s)
    //var sigma : Float = distTravelled * cos(pos.direction)
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 5.0
    assume frontObs ~ value(tsv)
    observe frontObs ~ Gaussian(frontEst, sigma)
  }
  var rearEst : Float = estimateDistanceRear(m, pos)
  loop for tsv in rear {
    //var distTravelled : Float = pos.speed * intToFloat(timestamp(tsv)) / intToFloat(1s)
    //var sigma : Float = 0.0 - distTravelled * cos(pos.direction)
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 5.0
    assume rearObs ~ value(tsv)
    observe rearObs ~ Gaussian(rearEst, sigma)
  }
  var leftEst : Float = estimateDistanceSideLeft(m, pos)
  loop for tsv in left {
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
    assume leftObs ~ value(tsv)
    observe leftObs ~ Gaussian(leftEst, sigma)
  }
  var rightEst : Float = estimateDistanceSideRight(m, pos)
  loop for tsv in right {
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
    assume rightObs ~ value(tsv)
    observe rightObs ~ Gaussian(rightEst, sigma)
  }

  cond if not(withinRoomBounds(m, pos)) {
    degenerate
  } else {}
  resample

  return pos
}

def positionEstimate(period : Int) : Unit {
  input front : Dist(Float)
  input rear : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input speed : Dist(Float)
  input steeringAngle : Float
  output pos : Dist(Pos)
  var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer d <- initialPositionModel(blocks) particles 1000
  loop {
    sdelay period
    read front to frontIn
    read rear to rearIn
    read left to leftIn
    read right to rightIn
    read speed to speedIn
    infer d <- positionModel(m, d, frontIn, rearIn, leftIn, rightIn, speedIn)
      budget posBudget
    write d to pos
  }
}

// TODO: add parameter configuring how "agressive" the braking should be, i.e.,
// how much risk we're willing to take.
// TODO: How do we inspect the samples of a distribution?
def brakeEstimate(period : Int) : Unit {
  input pos : Dist(Pos)
  output brake : Float
  loop {
    sdelay period
    read pos to posIn
  }
}

main {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not (what kind of value do
  // we want to write to this?)
  actuator brake : Float

  task speedEst = speedEst(500ms)
  task frontDist = ultrasonicDistance(500ms)
  task rearDist = ultrasonicDistance(500ms)
  task leftDist = tofDistance(500ms)
  task rightDist = tofDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(1s)

  // Network specification
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed
  speedEst.speed -> pos.speed
  frontLeft -> frontDist.ldist
  frontRight -> frontDist.rdist
  rearLeft -> rearDist.ldist
  rearRight -> rearDist.rdist
  sideLeft -> leftDist.distIn
  sideRight -> rightDist.distIn
  frontDist.dist -> pos.front
  rearDist.dist -> pos.rear
  leftDist.dist -> pos.left
  rightDist.dist -> pos.right
  steeringAngle -> pos.steeringAngle
  pos.pos -> brake.pos
  brake.brake -> brake
}
