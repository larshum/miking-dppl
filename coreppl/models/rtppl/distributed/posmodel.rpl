type RoomMap = {
  data : [[Bool]], rows : Int, cols : Int
}

type Coordinate = {row : Int, col : Int}

type Pos = { x : Float, y : Float, direction : Float }

type Offset = { angle : Float, distance : Float, direction : Float }

const roomBlockWidth : Float = 0.1
const maxSpeed : Float = 0.5
const wheelCircumference : Float = 0.35
const ultrasonicMaxRange : Float = 4.0
const tofMaxRange : Float = 2.0

const frontLeftOffset : Offset = {
  angle = 0.0-0.209639845874, distance = 0.240260275535, direction = 0.0
}
const frontRightOffset : Offset = {
  angle = 0.209639845874, distance = 0.240260275535, direction = 0.0
}
const rearLeftOffset : Offset = {
  angle = 0.0-2.76725903758, distance = 0.30083217913, direction = pi
}
const rearRightOffset : Offset = {
  angle = 2.76725903758, distance = 0.30083217913, direction = pi
}
const sideLeftOffset : Offset = {
  angle = 0.0-2.15879893034, distance = 0.126194294641, direction = (3.0 * pi) / 2.0
}
const sideRightOffset : Offset = {
  angle = 2.15879893034, distance = 0.126194294641, direction = pi / 2.0
}
const sensorOffsets : [Offset] = [
  frontLeftOffset, frontRightOffset, rearLeftOffset, rearRightOffset,
  sideLeftOffset, sideRightOffset
]

def readRoomMap() : RoomMap {
  var data : [[Bool]] = readRoomMapRuntimeHelper()
  return {data = data, rows = |data|, cols = |data[0]|}
}

def posToCoordinate(p : Pos) : Coordinate {
  return {
    row = floorToInt(p.y / roomBlockWidth),
    col = floorToInt(p.x / roomBlockWidth)
  }
}

def withinRoomBounds(m : RoomMap, p : Pos) : Bool {
  var c : Coordinate = posToCoordinate(p)
  var res : Bool = true
  cond res if ltInt(c.row, 0) || geqInt(c.row, m.rows) || ltInt(c.col, 0) || geqInt(c.col, m.cols) {
    res = false
  } else {
    res = not(m.data[c.row][c.col])
  }
  return res
}

def findFreeRoomCoordinates(m : RoomMap) : [Coordinate] {
  var blocks : [Coordinate] = []
  loop blocks for row in range(0, m.rows) {
    loop blocks for col in range(0, m.cols) {
      cond blocks if not(m.data[row][col]) {
        blocks = push(blocks, {row = row, col = col})
      } else {}
    }
  }
  return blocks
}

def absInt(x : Int) : Int {
  cond x if ltInt(x, 0) {
    x = negInt(x)
  } else {}
  return x
}

// Computes the sigma (of a normal distribution) based on the relative
// timestamp. We use this under the assumption that an observation made closer
// in time to 0 (the logically local time) should be considered more accurate.
// If the timestamp is too close to the logically local time, we use a
// pre-determined constant instead.
def timeRelativeSigma(ts : Int) : Float {
  var min : Float = 0.01
  var x : Float = intToFloat(absInt(ts)) / intToFloat(1s)
  cond x if x < min {
    x = min
  } else { }
  return x
}

// We estimate the current speed of the car based on the observed speeds from
// the left and right wheels. Note that this model does not make use of earlier
// estimations, as the current speed of the car does not depend much on the
// speed during our previous estimation. (it might be a good idea to include
// that as well)
def speedModel(prior : Dist(Float), observations : [TSV(Float)]) : Float {
  // Start from our earlier estimation of the speed (in meters per second).
  assume vprev ~ prior

  // Our new belief of the speed is normally distributed around our old belief.
  // TODO: choose sigma based on the max acceleration of the car.
  assume v ~ Gaussian(vprev, 0.1)

  loop for tsv in observations {
    var ts : Int = timestamp(tsv)
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 5.0
    var rpm : Float = value(tsv)
    var mps : Float = rpm * wheelCircumference / 60.0
    observe mps ~ Gaussian(v, sigma)
  }
  cond if v < 0.0-maxSpeed || v > maxSpeed {
    degenerate
  } else {}
  resample
  return v
}

def speedEst(period : Int) : Unit {
  input lspeed : Float
  input rspeed : Float
  output speed : Dist(Float)
  var d : Dist(Float) = Uniform(0.0-0.5, 0.5)
  loop d {
    sdelay period
    read lspeed to lin
    read rspeed to rin
    var obs : [TSV(Float)] = concat(lin, rin)
    infer d <- speedModel(d, obs) particles 1000
    write d to speed
  }
}

// Estimates the "true" distance between the car and an obstacle given
// observations from one or multiple sensors placed at a certain direction.
def distanceModel(prior : Dist(Float), obs : [TSV(Float)],
                  maxSensorRange : Float) : Float {
  // We sample from the prior to get the distance estimate from our previous
  // iteration.
  assume dprev ~ prior

  // We are uncertain about the new distance, but we assume it is related to
  // our previous estimate through a normal distribution.
  assume d ~ Gaussian(dprev, 1.0)

  loop for tsv in obs {
    var sigma : Float = timeRelativeSigma(timestamp(tsv))
    var obsDist : Float = value(tsv)
    // NOTE: The following approach assumes all observations provided by the
    // distance sensors are correct and relatively exact. This is true for the
    // simulator, but not for the car (in particular the ultrasonic sensors).
    cond if obsDist > maxSensorRange {
      cond if not(d > maxSensorRange) {
        degenerate
      } else {}
    } else {
      observe obsDist ~ Gaussian(d, sigma)
    }
  }

  cond if d < 0.0 || d > 10.0 {
    degenerate
  } else {}
  resample
  return d
}

// Estimates the distance observed by a particular sensor. This sensor is
// assumed to be installed at the provided offset relative to the center of the
// car.
def ultrasonicDistance(period : Int) : Unit {
  input distObs : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distObs to obs
    infer d <- distanceModel(d, obs, ultrasonicMaxRange) particles 1000
    write d to dist
  }
}

def tofDistance(period : Int) : Unit {
  input distObs : Float
  output dist : Dist(Float)
  var d : Dist(Float) = Uniform(0.0, 10.0)
  loop d {
    sdelay period
    read distObs to obs
    infer d <- distanceModel(d, obs, tofMaxRange) particles 1000
    write d to dist
  }
}

// We choose the initial position by choosing a random block of the map,
// and then sampling coordinates within the block. We assume that the initial
// direction of the car relative to the map is known, and that the car is
// stationary when the model starts running.
def initialPositionModel(blocks : [Coordinate]) : Pos {
  var c : Coordinate = randElemExn(blocks)
  var x : Float = intToFloat(c.col) * roomBlockWidth
  var y : Float = intToFloat(c.row) * roomBlockWidth
  assume xOfs ~ Uniform(0.0, roomBlockWidth)
  assume yOfs ~ Uniform(0.0, roomBlockWidth)
  return { x = x + xOfs, y = y + yOfs, direction = pi }
}

// TODO: Take the sensor offsets into account when estimating the distance.
// The position denotes our belief of the center of the car.
def estimateDistance(m : RoomMap, ofs : Offset, p : Pos) : Float {
  p.x = p.x + ofs.distance * cos(p.direction + ofs.angle)
  p.y = p.y + ofs.distance * sin(p.direction + ofs.angle)
  p.direction = p.direction + ofs.direction
  var eps : Float = 0.05
  var acc : {d : Float, p : Pos} = {d = 0.0, p = p}
  loop acc while withinRoomBounds(m, acc.p) {
    var p : Pos = acc.p
    p.x = p.x + eps * cos(p.direction)
    p.y = p.y + eps * sin(p.direction)
    acc.d = acc.d + eps
    acc.p = p
  }
  return acc.d
}

def observeSensor(m : RoomMap, pos : Pos, sensorOffset : Offset,
									obs : [TSV(Dist(Float))]) : Unit {
  var estDist : Float = estimateDistance(m, sensorOffset, pos)
  loop for tsv in obs {
    var sigma : Float = timeRelativeSigma(timestamp(tsv)) / 10.0
    assume obsDist ~ value(tsv)
    observe obsDist ~ Gaussian(estDist, sigma)
  }
}

def positionModel(m : RoomMap, prior : Dist(Pos), flObs : [TSV(Dist(Float))],
                  frObs : [TSV(Dist(Float))], rlObs : [TSV(Dist(Float))],
                  rrObs : [TSV(Dist(Float))], lObs : [TSV(Dist(Float))],
                  rObs : [TSV(Dist(Float))]) : Pos {
  assume posPrev ~ prior

  // Perform a naive transition model from the position we estimated the car
  // was in during the previous iteration.
  assume x ~ Gaussian(posPrev.x, 1.0)
  assume y ~ Gaussian(posPrev.y, 1.0)
  assume d ~ Gaussian(posPrev.direction, pi / 4.0)
  var pos : Pos = {x = x, y = y, direction = d}

  // Update our belief based on the observations we made.
  var sensorObservations : [[TSV(Dist(Float))]] = [
    flObs, frObs, rlObs, rrObs, lObs, rObs
  ]
  loop for i in range(0, |sensorOffsets|) {
    observeSensor(m, pos, sensorOffsets[i], sensorObservations[i])
  }

  cond if not(withinRoomBounds(m, pos)) {
    degenerate
  } else {}
  resample

  return pos
}

def positionEstimate(period : Int) : Unit {
  input frontLeft : Dist(Float)
  input frontRight : Dist(Float)
  input rearLeft : Dist(Float)
  input rearRight : Dist(Float)
  input left : Dist(Float)
  input right : Dist(Float)
  input speed : Dist(Float)
  input steeringAngle : Float
  output pos : Dist(Pos)
  var posBudget : Int = subInt(period, 100ms)
  var m : RoomMap = readRoomMap()
  var blocks : [Coordinate] = findFreeRoomCoordinates(m)
  infer d <- initialPositionModel(blocks) particles 1000
  loop {
    sdelay period
    read frontLeft to flObs
    read frontRight to frObs
    read rearLeft to rlObs
    read rearRight to rrObs
    read left to lObs
    read right to rObs
    read speed to speedIn
    infer d <- positionModel(m, d, flObs, frObs, rlObs, rrObs, lObs, rObs)
      budget posBudget
    write d to pos
  }
}

// TODO: add parameter configuring how "agressive" the braking should be, i.e.,
// how much risk we're willing to take.
// TODO: How do we inspect the samples of a distribution?
def brakeEstimate(period : Int) : Unit {
  input pos : Dist(Pos)
  output brake : Float
  loop {
    sdelay period
    read pos to posIn
    write 0.0 to brake
  }
}

main {
  // Distance sensors
  sensor frontLeft : Float
  sensor frontRight : Float
  sensor rearLeft : Float
  sensor rearRight : Float
  sensor sideLeft : Float
  sensor sideRight : Float

  // Wheel sensors
  sensor speedLeft : Float
  sensor speedRight : Float
  sensor steeringAngle : Float

  // Brake actuator - determines whether to brake or not (what kind of value do
  // we want to write to this?)
  actuator brake : Float

  task speedEst = speedEst(500ms)
  task frontLeftDist = ultrasonicDistance(500ms)
  task frontRightDist = ultrasonicDistance(500ms)
  task rearLeftDist = ultrasonicDistance(500ms)
  task rearRightDist = ultrasonicDistance(500ms)
  task leftDist = tofDistance(500ms)
  task rightDist = tofDistance(500ms)
  task pos = positionEstimate(1s)
  task brake = brakeEstimate(1s)

  // Network specification
  speedLeft -> speedEst.lspeed
  speedRight -> speedEst.rspeed
  speedEst.speed -> pos.speed

  frontLeft -> frontLeftDist.distObs
  frontRight -> frontRightDist.distObs
  rearLeft -> rearLeftDist.distObs
  rearRight -> rearRightDist.distObs
  sideLeft -> leftDist.distObs
  sideRight -> rightDist.distObs
  frontLeftDist.dist -> pos.frontLeft
  frontRightDist.dist -> pos.frontRight
  rearLeftDist.dist -> pos.rearLeft
  rearRightDist.dist -> pos.rearRight
  leftDist.dist -> pos.left
  rightDist.dist -> pos.right
  steeringAngle -> pos.steeringAngle
  pos.pos -> brake.pos
  brake.brake -> brake
}
